### 配额（Quotas）

Kafka集群具有对请求进行配额的能力，可以控制客户端使用的代理资源。每个客户端群组共享一个配额，Kafka代理可以执行两种类型的客户端配额：

1. **网络带宽配额**定义字节速率阈值（从0.9开始）
2. **请求率配额**定义CPU利用阈值为网络和I/O线程的一个百分比（从0.11开始）。

#### 1、为何需要配额

生产者和消费者可能会生产或消费很大量的数据，或者以非常高的速率产生请求，这样的话可能会独占代理资源，导致**网络饱和**、通常地**DOS（拒绝服务）**其它客户端和代理自身。使用配额可以防止这些状况发生，在大型的多租户的集群中配额更加重要，因为少数异常行为的客户端可能回使正常的客户端用户体验降低。事实上，运行Kafka为一个服务时，配额还可以根据约定进行API限制。

#### 2、客户端群组

在一个安全集群中，Kafka客户端的身份是代表一个认证的用户的用户主体。在支持未认证客户端的集群中，用户主体是有代理使用可配置的`PrincipalBuilder`选择的一组未认证的用户。client-id是由客户端应用选择的具有实际意义的名字的一个客户端的逻辑组。元组(user,client-id)定义了一个共享用户主题和客户端Id的安全的客户端的逻辑组。

配额可以应用到(user, client-id)、用户或者client-id组。对于指定连接，匹配连接的**最具体的配额**才会被应用。一个配额组的所有连接共享为这个组配置的配额。比如，如果(user="test-user",client-id="test-client")有一个10MB/sec的生产配额，那么这个配额是由具有client-id为"test-client"的用户“test-user”的所有生产者实例共享的。

#### 3、配额配置

配额配置可以是针对(user, client-id)、用户或者client-id组的。可以在需要更高（或者更低）配额的任意的配额级别覆盖默认的配额。这种机制与每个主题日志配置的覆盖类似。(user, client-id)、用户配额覆盖是写到ZooKeeper的***/config/users***下的，client-id配额覆盖是写到***/config/clients***下的。这些覆盖会被所有的代理读取并立即生效。这可以在不需要重启整个集群的情况下改变配额。每个组的默认配额也可以使用相同的机制动态地进行更新。

配额配置的**优先级顺序**如下：

1. /config/users/<user&gt;/clients/<client-id&gt;
2. /config/users/<user&gt;/clients/<default&gt;
3. /config/users/<user&gt;
4. /config/users/<default&gt;/clients/<client-id&gt;
5. /config/users/<default&gt;/clients/<default&gt;
6. /config/users/<default&gt;
7. /config/clients/<client-id&gt;
8. /config/clients/<default&gt;

代理属性（`quota.producer.default`，`quota.consumer.default`）也可以用来为client-id组设置默认的网络带宽配额。这些属性会在未来的发布版本中移除。client-id的默认配额可以通过与其它配额覆盖和默认类似的进行设置。

#### 4、网络带宽配额

网络贷款配额定义为字节速率阈值，每个组的客户端共享一个配额。默认情况下，每个唯一的客户端群组接收一个集群配置的以字节/秒为单位的固定的配额。这个配额是**针对每个代理**进行定义的。每个客户端群组最多可以对每个代理以***X***字节/秒的速率进行发布/获取。

#### 5、请求率配额（Request Rate Quotas）

请求率配额定义为：客户端可以在配额窗口内使用每个代理的请求处理程序I/O线程和网络线程的时间百分比。一个 $$n\%$$ 的配额表示一个线程的 $$n\%$$ ，所以这个配额是总容量的 $$((num.io.threads + num.network.threads) * 100) \%$$ 中的一部分。在配额窗口内，每个客户端群组可以使用最多总计 $$n\%$$ 的所有I/O和网络线程。由于分配给I/O和网络线程的线程数量是基于代理的主机可用核心数量的，请求率指标代表了共享配额的群组的客户端可以使用的CPU的总数的百分比。

#### 6、执行

默认情况下，每个唯一地客户端接收一个由集群配置的固定配额。这个配额是针对每个代理定义的。每个客户端在配额打满之前，可以利用每个代理这个配额量的资源。为每个代理定义配额比定一个客户端的集群配额更好，因为后者需要一个在所有代理中共享客户端配额使用的机制，这种机制的实现比配额实现本身更困难。

代理发现**超过配额时怎么应对**？代理首先计算使超过配额客户端合格需要的延时，并马上返回一个带有这个延时的响应。对于获取请求，这个响应不包含任何数据。然后，代理会使这个客户端的channel静默，不再处理这个客户端的请求，直到延时结束。收到具有非零延时的响应后，Kafka客户端会在延时时间内避免发送更多请求到代理。因而，受限客户端的请求在两侧都被高效地阻塞。即使更老版本的客户端实现不关心代理的 延时响应，代理通过静默该客户的的socket channel也能限制这些客户端。这些客户端向受限的channel发送的请求只有在延时结束后才会收到响应。

字节率和线程利用是通过多重的小窗口进行衡量的（比如，30个1秒的窗口），以便快速侦测和纠正违反配额的情况。一般地，大的衡量窗口（比如，10个30秒的窗口）会导致大量的通信进而导致长的延时，就用户体验来讲这是不好的。