### 消费者

Kafka通过向保存着它想要消费的分区的leader的代理发送“fetch”请求而工作。消费者每个请求都指定日志中的偏移量（offset），并且获取从那个偏移开始的一大块日志。消费者可以自由的控制偏移量，并且如果需要可以回放日志以重复消费数据。

#### 1、Push和Pull

首先要考虑的问题是，消费者从代理拉数据还是代理网消费者推数据。在这方面采用了一个更加传统的设计，也是大多数消息系统才用的，数据被从生产者推送到代理，消费者从代理拉数据。某些日志收集系统，比如Scribe和Apache Flume，采用了与众不同的推送数据方式，数据是被推送到下游的。它们各有优缺点。但是，基于推送的系统在处理不同消费方面有困难，因为代理控制了数据传输的速率。目标一般是消费者能够以最大的可能速率消费；不幸的是，在推送系统中，这意味着当消费速率低于生产速率时消费者可能会崩溃（本质上是拒绝服务攻击）。基于拉取的系统有更好的属性，落后的消费者在能够的时候可以追赶消费。

**基于拉取的系统**的另一个优势是它有助于对发送给消费者的数据进行积极的批处理。基于推送的系统必须选择直接发送请求，或者累积更多的数据，然后在不知道下游消费者是否能够马上进行处理的情况下发送。如果调整为低延时，结果会是一次只发送一条消息，只是为了传输能够清空缓存的消息，这是很浪费的。基于拉取得系统中，消费者总是拉取日志中当前位置之后的所有（或者之多达到配置的最大值的）消息。这样在没有引入不必要的延时的情况下获得最佳的批处理。

单纯的基于拉取的系统的不足是，如果代理没有数据，消费者可能会停止以紧密的循环进行消息拉取，而是忙于等待数据的到达。为了避免这种情况，Kafka消费者拉取请求有参数可以让消费者请求阻塞在一个**“长拉取”（“long poll”）**等待中直到数据到达（并且，还可以选择等待消息量积累到一定的字节以确保较大的传输数据量）。

#### 2、消费者的位置

消息系统的一个关键系能点是，保持追踪什么被消费过了。

大多数消息系统会在代理上保存哪些消息已经被消费过了的元数据。即，当消息被交给消费者后，代理直接本地地记录这件事或者等待消费者的确认信息。这是一个相当直观地选择，但是可能不明显得是让代理和消费者对什么被消费过不是小问题。如果代理在把消息交给网络时马上标记它为被消费的，然后如果消费者处理消息失败，那么这条消息就会丢失。为了解决这个问题，许多消息系统增加了一个确认特性，这意味着消息发出后被标记为发送但是没有消费过，代理等待一个来自消费者的特殊确认来标记消息为消费过的。这种策略修复了消息丢失的问题，但是造成了新的问题。首先，如果消费者处理了消息但是在发送确认之前故障了，那么会消费信息两次。第二个问题是性能方面的，代理必须保存每个消息的多种状态（首先锁定消息以便消息不会发出两次，其次标记消息为永久地消费过了所以可以移除消息了）。必须要处理诡异的问题，比如怎么处理那些已经发出但是没有确认的消息。

Kafka处理方式不同，**主题被划分为完全地有序的分区集合，同一时间每个分区只能被每个订阅消费者组中的一个消费者消费**。这意味着每个分区中每个消费者的位置只是一个整数，即下一条要被消费的消息的偏移量。这使得被消费过的消息的状态十分简单，对于每个分区来说只是一个数字。这个状态可以被周期性的进行checkpointed。这也使得等价的消息确认很容易。

Kafka这种设计还有一个好处，消费者可以回头重新消费数据。这违背了队列的一般协议，但是对许多消费者来说是一个必要的特性。比如，如果消费者代码有bug，并且消费了一些消息后发现了bug，bug修复后消费者可以重新消费这些消息。

#### 3、离线数据加载

可扩展的持久性使得消费者可以仅仅周期性地消费，比如消费周期性地批次加载到像Hadoop或者关系型数据仓库这样的离线系统的批数据加载。

对于Hadoop的情况，通过将加载分隔为单个的map tasks以并行化数据的加载，每个node/topic/partition组合一个任务，可以在加载中完全并行化地进行。Hadoop提供了task管理，失败的tasks可以重新运行而不会有数据重复的风险——它们只是简单地从它们的原始位置重新运行。

#### 4、静态成员（Static Membership）

静态成员关系目标是提升流应用、消费者组和其它基于组再平衡协议构建的应用的可用性。组再平衡协议依赖于组协调器为组成员分配条目ids。这些生成的ids是短暂的，并且当成员重启和重新加入时会改变。对于基于消费者的应用，这种“动态成员”在管理操作过程中（比如代码部署，配置更新和周期性重启）会导致大部分的任务重新分配给不同的实例。对于大型状态应用，进行处理之前洗牌任务需要很长时间来恢复它们的本地状态，并且会导致应用部分或者全部不可用。鉴于这种情况，Kafka的组管理协议**允许组成员提供持久性的条目ids**。基于这些ids组成员关系不会改变，因此不会触发再平衡。

如果想要使用静态成员关系：

- 更新客户端应用和代理集群为2.3或以上，并且也要确保更新后的代理在使用2.3或以上的`inter.broker.protocol.version`。
- 设置配置`ConsumerConfig#GROUP_INSTANCE_ID_CONFIG`为一个组下每个消费者实例都唯一的值。
- 对于Kafka流应用，为每一个KafkaStreams实例设置一个唯一的`ConsumerConfig#GROUP_INSTANCE_ID_CONFIG`就可以了，与实例使用的线程数无关。

如果代理是比2.3更老的版本，但是在客户端侧设置了`ConsumerConfig#GROUP_INSTANCE_ID_CONFIG`，应用会检测代理版本并且会抛出`UnsupportedException`。如果不小心为不同的实例配置了重复的ids，代理侧的围栏机制会通过触发一个`org.apache.kafka.common.errors.FencedInstanceIdException`来告知重复的客户端马上关闭。

